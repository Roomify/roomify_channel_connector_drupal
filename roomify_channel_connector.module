<?php
/**
 * @file
 * Code for the roomify_channel_connector feature.
 */

use Roomify\Bat\Event\Event;
use Roomify\Bat\Calendar\Calendar;
use Roomify\Bat\Store\DrupalDBStore;
use Roomify\Bat\Unit\Unit;

include_once 'roomify_channel_connector.features.inc';

define('CM_URL', 'http://rcc.app/index_dev.php/');

/**
 * Implements hook_menu().
 */
function roomify_channel_connector_menu() {
  $items = array();

  // Channel management tab for units.
  $items['admin/config/services/channel-management'] = array(
    'title' => 'Roomify Channel Management',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('roomify_channel_connector_configuration_form'),
    'access arguments' => array('configure channel management'),
    'type' => MENU_NORMAL_ITEM,
    'description' => 'Configuration for the Roomify Channel Management service',
  );

  // Channel management tab for units.
  $items['admin/bat/config/property/manage/%roomify_property/channel-management'] = array(
    'title' => 'Channel Management',
    'page callback' => 'roomify_channel_connector_management_tab',
    'page arguments' => array(5),
    'access arguments' => array('manage property channels'),
    'type' => MENU_LOCAL_TASK,
    'weight' => '20',
  );

  return $items;
}

/**
 * Implements hook_permission()
 */
function roomify_channel_connector_permission() {
  return array(
    'configure channel management' =>  array(
      'title' => t('Configure Channel Management'),
      'description' => t('Configure Roomify Channel Management.'),
    ),
    'manage property channels' =>  array(
      'title' => t('Manage Property Channels'),
      'description' => t('Access the Channel Management tab on properties.'),
    ),
    'create channel reservations' =>  array(
      'title' => t('Create Channel Reservations'),
      'description' => t('Create Channel Reservations.'),
    ),
    'retrieve channel availability information' => array(
      'title' => t('Retrieve channel availability info'),
      'description' => t('Retrieve channel availability info'),
    ),
    'retrieve rate information' => array(
    'title' => t('Retrieve channel rate info'),
    'description' => t('Retrieve channel rate info'),
  )

  );
}

/**
 * Module configuration form.
 */
function roomify_channel_connector_configuration_form($form, &$form_state) {
  $form['roomify_channel_connector_site_id'] = array(
    '#type' => 'textfield',
    '#title' => t('Roomify Site ID'),
    '#description' => t('Enter the Site ID you were given when subscribing to the Roomify channel management service.'),
    '#element_validate' => array('element_validate_integer_positive'),
    '#default_value' => roomify_channel_connector_get_site_id(),
  );

  $form['roomify_channel_connector_site_token'] = array(
    '#type' => 'textfield',
    '#title' => t('Roomify Site Token'),
    '#description' => t('Enter the Site Token you were given when subscribing to the Roomify channel management service.'),
    '#default_value' => variable_get('roomify_channel_connector_site_token', ''),
  );

  return system_settings_form($form);
}

function roomify_channel_connector_services_resources() {
  $resources = array();

  $resources['channel-reservation'] = array(
    'operations' => array(
      'create' => array( 
        'callback' => 'roomify_channel_connector_create',
        'help' => t('Creates a new reservation through the channel manager'),
        'access arguments' => array('create channel reservations'),
        'args' => array(
          array(
            'name' => 'reservation',
            'type' => 'array',
            'description' => 'The reservation object',
            'source' => 'data',
            'optional' => FALSE,
          ),
        ),
      ),
    ),
  );

  $resources['channel-availability'] = array(
    'operations' => array(
      'index' => array(
        'callback' => 'roomify_channel_connector_availability',
        'help' => t('Returns availability information in Json.'),
        'access arguments' => array('retrieve channel availability information'),
        'args'     => array(
          array(
            'name'         => 'property_id',
            'type'         => 'string',
            'description'  => t('The property id for which to retrieve info - should be mapped correctly'),
            'source'       => array('path' => 0),
            'optional'     => TRUE,
          ),
          array(
            'name'         => 'room_id',
            'type'         => 'string',
            'description'  => t('The roomid for which to retrieve availability info'),
            'source'       => array('path' => 1),
            'optional'     => TRUE,
          ),
          array(
            'name'         => 'rate_id',
            'type'         => 'string',
            'description'  => t('The rateid for which to retrieve availability info'),
            'source'       => array('path' => 2),
            'optional'     => TRUE,
          ),
          array(
            'name'         => 'start_date',
            'type'         => 'string',
            'description'  => t('The start date for which to retrieve availability info - e.g. 2016-03-01'),
            'source'       => array('path' => 3),
            'optional'     => TRUE,
          ),
          array(
            'name'         => 'end_date',
            'type'         => 'string',
            'description'  => t('The end date for which to retrieve availability info - e.g. 2016-03-01'),
            'source'       => array('path' => 4),
            'optional'     => TRUE,
          ),

        ),
      ),
    ),
  );

  $resources['type-availability'] = array(
    'operations' => array(
      'index' => array(
        'callback' => 'roomify_channel_type_availability',
        'help' => t('Returns availability information for a bat type in Json.'),
        'access arguments' => array('retrieve type availability information'),
        'args'     => array(
          array(
            'name'         => 'property_id',
            'type'         => 'string',
            'description'  => t('The property id for which to retrieve info - should be mapped correctly'),
            'source'       => array('path' => 0),
            'optional'     => TRUE,
          ),
          array(
            'name'         => 'type_id',
            'type'         => 'string',
            'description'  => t('The  type id for which to retrieve availability info'),
            'source'       => array('path' => 1),
            'optional'     => TRUE,
          ),
          array(
            'name'         => 'start_date',
            'type'         => 'string',
            'description'  => t('The start date for which to retrieve availability info - e.g. 2016-03-01'),
            'source'       => array('path' => 2),
            'optional'     => TRUE,
          ),
          array(
            'name'         => 'end_date',
            'type'         => 'string',
            'description'  => t('The end date for which to retrieve availability info - e.g. 2016-03-01'),
            'source'       => array('path' => 3),
            'optional'     => TRUE,
          ),

        ),
      ),
    ),
  );

  $resources['channel-rates'] = array(
    'operations' => array(
      'index' => array(
        'callback' => 'roomify_channel_connector_rates',
        'help' => t('Returns rate information in Json.'),
        'access arguments' => array('retrieve bcom rate information'),
        'args'     => array(
          array(
            'name'         => 'property_id',
            'type'         => 'string',
            'description'  => t('The property id for which to retrieve info - should be mapped correctly'),
            'source'       => array('path' => 0),
            'optional'     => TRUE,
          ),
          array(
            'name'         => 'room_id',
            'type'         => 'string',
            'description'  => t('The room_id for which to retrieve availability info'),
            'source'       => array('path' => 1),
            'optional'     => TRUE,
          ),
          array(
            'name'         => 'rate_id',
            'type'         => 'string',
            'description'  => t('The rate_id for which to retrieve availability info'),
            'source'       => array('path' => 2),
            'optional'     => TRUE,
          ),
          array(
            'name'         => 'start_date',
            'type'         => 'string',
            'description'  => t('The start date for which to retrieve availability info - e.g. 2016-03-01'),
            'source'       => array('path' => 3),
            'optional'     => TRUE,
          ),
          array(
            'name'         => 'end_date',
            'type'         => 'string',
            'description'  => t('The end date for which to retrieve availability info - e.g. 2016-03-01'),
            'source'       => array('path' => 4),
            'optional'     => TRUE,
          ),

        ),
      ),
    ),
  );

  return $resources;
}

/**
 * Creates a booking of type booking.com
 *
 * @param $reservations
 * @return string
 */
function roomify_channel_connector_create($reservations) {
  watchdog('Channel Manager', 'Bookingcom Create Reservation Called', array(), WATCHDOG_INFO);
  $reply  = array();

  foreach ($reservations as $reservation) {

    // Let us check if cancelled and deal with that
    if ($reservation['status'] == 'cancelled') {
      // We should have all the bookings associated with this reservation so let's load them and set status to cancelled
      $efq = new EntityFieldQuery();
      $efq->entityCondition('entity_type', 'bat_booking')
        ->entityCondition('bundle', 'booking_com', '=')
        ->fieldCondition('field_bcom_reservation_id', 'value', $reservation['id'], '=');

      $bookings = $efq->execute();

      if (isset($bookings['bat_booking'])) {
        // cycle through each booking and set status to cancelled
        foreach ($bookings['bat_booking'] as $key => $booking) {
          $cm_room = bat_booking_load($key);
          $cm_room->field_bcom_status[LANGUAGE_NONE][0]['value'] = "cancelled";
          $cm_room->field_bcom_cancellation_fee[LANGUAGE_NONE][0]['value'] = $reservation['total_cancellation_fee'];

          $cm_room->save();
          watchdog('Channel Manager', 'Booking.com reservation ' . $reservation['id'] . ' cancelled', array(), WATCHDOG_INFO);
          $reply[] = 'Booking.com reservation ' . $reservation['id'] . ' cancelled';
        }
      }

      return json_encode($reply);
    }

    // With modified reservations two things can happen. 1. A room is completely cancelled or room data has been altered or changed.
    // We should remove all existing bookings and create new ones with status modified.
    if ($reservation['status'] == 'modified') {

      // We start by getting all the bookings on our system and check if they still match bookings on the other side, bookings
      // that are lost are set to cancelled, the ones that remain are set to modified.
      $efq = new EntityFieldQuery();
      $efq->entityCondition('entity_type', 'bat_booking')
        ->entityCondition('bundle', 'booking_com', '=')
        ->fieldCondition('field_bcom_reservation_id', 'value', $reservation['id'], '=');

      $bookings = $efq->execute();

      if (isset($bookings['bat_booking'])) {
        // Cycle through the rooms coming from Booking.com
        $bookingrooms = array();
        foreach ($reservation['rooms'] as $room) {
          $bookingrooms[$room['roomreservation_id']] = $room['roomreservation_id'];
        }

        // Do a comparison between room info we got and room info that we have and set any rooms that got cancelled
        foreach ($bookings['bat_booking'] as $key => $booking) {
          $cm_room = bat_booking_load($key);
          // Check if the booking still exists
          if (isset($bookingrooms[$cm_room->field_bcom_room_reservation_id[LANGUAGE_NONE][0]['value']])) {
            // we are good room is still there
          }
          else {
            $cm_room->field_bcom_status[LANGUAGE_NONE][0]['value'] = "cancelled";
            $cm_room->save();
            watchdog('Channel Manager', 'Booking.com room reservation ' . $cm_room->field_bcom_room_reservation_id[LANGUAGE_NONE][0]['value'] . ' cancelled', array(), WATCHDOG_INFO);
            $reply[] = 'Booking.com room reservation ' . $cm_room->field_bcom_room_reservation_id[LANGUAGE_NONE][0]['value'] . ' cancelled';

          }
        }

      }
    }


    // Now we move on with dealing with reservation data knowing that we may be creating or modifying existing rooms or dealing with
    // a new reservation.
    foreach ($reservation['rooms'] as $room) {
      global $user;


      // Check if we are dealing with an existing reservation
      $efq = new EntityFieldQuery();
      $efq->entityCondition('entity_type', 'bat_booking')
        ->entityCondition('bundle', 'booking_com', '=')
        ->fieldCondition('field_bcom_reservation_id', 'value', $reservation['id'], '=')
        ->fieldCondition('field_bcom_room_reservation_id', 'value',  $room['roomreservation_id'], '=');

      $result = $efq->execute();

      if (isset($result['bat_booking'])) {
        $return = key($result['bat_booking']);
        $booking = bat_booking_load($return);
        $updated_time = $reservation['date'] . ' ' . $reservation['time'];
        $booking->changed = strtotime($updated_time);
        watchdog('Channel Manager', 'Booking.com reservation ' . $room['roomreservation_id'] . ' updated', array(), WATCHDOG_INFO);
        $reply[] = 'Booking.com reservation ' . $room['roomreservation_id'] . ' updated';
      }
      else {
        // Create a new booking.
        $created_time = $reservation['date'] . ' ' . $reservation['time'];
        $booking = bat_booking_create(array(
          'type' => 'booking_com',
          'uid' => $user->uid,
          'created' => strtotime($created_time),
        ));
        watchdog('Channel Manager', 'Booking.com reservation ' . $room['roomreservation_id'] . ' created', array(), WATCHDOG_INFO);
        $reply[] = 'Booking.com reservation ' . $room['roomreservation_id'] . ' created';

      }

      $booking->field_bcom_room_reservation_id[LANGUAGE_NONE][0]['value'] = $room['roomreservation_id'];

      //Start Date for the booking
      $booking->field_bcom_arrival_date[LANGUAGE_NONE][0]['value'] = $room['arrival_date'];
      $booking->booking_start_date[LANGUAGE_NONE][0]['value'] = $room['arrival_date'];

      //End Date for the booking
      $booking->field_bcom_departure_date[LANGUAGE_NONE][0]['value'] = $room['departure_date'];
      $booking->booking_end_date[LANGUAGE_NONE][0]['value'] = $room['departure_date'];

      $price_index = 0;
      foreach ($room['price'] as $price) {
        $booking->field_bcom_price_data_per_date[LANGUAGE_NONE][$price_index]['value'] = drupal_json_encode($price);
        $price_index++;
      }

      $booking->field_bcom_room_commission[LANGUAGE_NONE][0]['value'] = $room['commissionamount'];
      $booking->field_bcom_room_total_price[LANGUAGE_NONE][0]['value'] = $room['totalprice'];
      $booking->field_bcom_room_currency_code[LANGUAGE_NONE][0]['value'] = $room['currencycode'];
      $booking->field_bcom_extra_info[LANGUAGE_NONE][0]['value'] = $room['extra_info'];
      $booking->field_bcom_facilities[LANGUAGE_NONE][0]['value'] = $room['facilities'];
      $booking->field_bcom_guest_name[LANGUAGE_NONE][0]['value'] = $room['guest_name'];
      $booking->field_bcom_room_id[LANGUAGE_NONE][0]['value'] = $room['id'];
      $booking->field_bcom_room_info[LANGUAGE_NONE][0]['value'] = $room['extra_info'];
      $booking->field_bcom_max_children[LANGUAGE_NONE][0]['value'] = $room['max_children'];
      $booking->field_bcom_meal_plan[LANGUAGE_NONE][0]['value'] = $room['meal_plan'];
      $booking->field_bcom_room_type_name[LANGUAGE_NONE][0]['value'] = $room['name'];
      $booking->field_bcom_number_of_guests[LANGUAGE_NONE][0]['value'] = $room['numberofguests'];
      $booking->field_bcom_room_remarks[LANGUAGE_NONE][0]['value'] = $room['remarks'];
      $booking->field_bcom_smoking[LANGUAGE_NONE][0]['value'] = $room['smoking'];

      // Add the generic reservation data
      $booking->field_bcom_reservation_id[LANGUAGE_NONE][0]['value'] = $reservation['id'];
      $booking->field_bcom_status[LANGUAGE_NONE][0]['value'] = $reservation['status'];
      $booking->field_bcom_reservation_time[LANGUAGE_NONE][0]['value'] = $reservation['date'] . ' - ' . $reservation['time'];
      $reservation_time = $reservation['date'] . ' ' . $reservation['time'];
      $booking->changed = strtotime($reservation_time);

      $booking->field_bcom_commission_amount[LANGUAGE_NONE][0]['value'] = $reservation['commissionamount'];
      $booking->field_bcom_currency_code[LANGUAGE_NONE][0]['value'] = $reservation['currencycode'];
      $booking->field_bcom_reservation_date[LANGUAGE_NONE][0]['value'] = $reservation['date'];
      $booking->field_bcom_hotel_id[LANGUAGE_NONE][0]['value'] = $reservation['hotel_id'];
      $booking->field_bcom_hotel_name[LANGUAGE_NONE][0]['value'] = $reservation['hotel_name'];
      $booking->field_bcom_total_price[LANGUAGE_NONE][0]['value'] = $reservation['totalprice'];

      // Add the customer data
      $booking->field_bcom_first_name[LANGUAGE_NONE][0]['value'] = $reservation['customer']['first_name'];
      $booking->field_bcom_last_name[LANGUAGE_NONE][0]['value'] = $reservation['customer']['last_name'];
      $booking->field_bcom_email[LANGUAGE_NONE][0]['value'] = $reservation['customer']['email'];
      $booking->field_bcom_telephone[LANGUAGE_NONE][0]['value'] = $reservation['customer']['telephone'];
      $booking->field_bcom_company[LANGUAGE_NONE][0]['value'] = $reservation['customer']['company'];
      $booking->field_bcom_address[LANGUAGE_NONE][0]['value'] = $reservation['customer']['address'];
      $booking->field_bcom_city[LANGUAGE_NONE][0]['value'] = $reservation['customer']['city'];
      $booking->field_bcom_zip[LANGUAGE_NONE][0]['value'] = $reservation['customer']['zip'];
      $booking->field_bcom_countrycode[LANGUAGE_NONE][0]['value'] = $reservation['customer']['countrycode'];
      $booking->field_bcom_cc_cvc[LANGUAGE_NONE][0]['value'] = $reservation['customer']['cc_cvc'];
      $booking->field_bcom_cc_expiration_date[LANGUAGE_NONE][0]['value'] = $reservation['customer']['cc_expiration_date'];
      $booking->field_bcom_cc_name[LANGUAGE_NONE][0]['value'] = $reservation['customer']['cc_name'];
      $booking->field_bcom_cc_number[LANGUAGE_NONE][0]['value'] = $reservation['customer']['cc_number'];
      $booking->field_bcom_cc_type[LANGUAGE_NONE][0]['value'] = $reservation['customer']['cc_type'];
      $booking->field_bcom_dc_issue_numebr[LANGUAGE_NONE][0]['value'] = $reservation['customer']['dc_issue_number'];
      $booking->field_bcom_dc_start_date[LANGUAGE_NONE][0]['value'] = $reservation['customer']['dc_start_date'];
      $booking->field_bcom_remarks[LANGUAGE_NONE][0]['value'] = $reservation['customer']['remarks'];

      $booking->save();

      watchdog('Channel Manager', 'Booking.com reservation ' . $room['roomreservation_id'] . ' saved', array(), WATCHDOG_INFO);
      $reply[] = 'Booking.com reservation ' . $room['roomreservation_id'] . ' saved';
    }
  }

  return drupal_json_encode($reply);
}

/**
 * Retrieve availability information for a given date range and format appropriately
 *
 * @param $property_id
 * @param $room_id
 * @param $rate_id
 * @param $start_date
 * @param $end_date
 * @return array
 */
function roomify_channel_connector_availability($property_id, $room_id, $rate_id, $start_date, $end_date) {

  // First we should map the hotelid and roomid to a property and room
  $roomify_room_id = roomify_channel_connector_get_type_id($property_id, $room_id, $rate_id);

  if ($roomify_room_id == NULL) {
    return '';
  }

  // Assuming we have that then we load all the units associated with that type
  $controller = entity_get_controller('bat_unit');

  // Get the units that belong to the relevant room id
  $entities = $controller->getReferencedIds($roomify_room_id);

  // Create an array of unit objects - that we will pass to the calendar
  $units = array();
  foreach ($entities as $entity) {
    $eo = bat_unit_load($entity['id']);
    $units[] = new Unit($entity['id'], $eo->getEventDefaultValue('availability'));
  }

  // Create an event store for availability type events
  $event_store = new DrupalDBStore('availability', DrupalDBStore::BAT_STATE);

  // Provided that we have units let's check availability
  if (!empty($units)) {
    $calendar = new Calendar($units, $event_store);

    $interval = new \DateInterval('P1D');
    $daterange = new \DatePeriod(new \DateTime($start_date), $interval, new \DateTime($end_date));

    $rooms_available = array();
    foreach ($daterange as $date) {
      $response = $calendar->getMatchingUnits($date, $date, array(1) );
      $rooms_available[$date->format('Y-m-d')] = count($response->getIncluded());
    }

    // With the units in place we can create the properly formatted message to sent to booking.com
    $message = array();
    $i = -1;
    $old_count = 0;
    $start = TRUE;
    foreach ($rooms_available as $day => $rooms) {
      if ($old_count != $rooms) {
        $start_date = $day;
        $i++;
      }
      // Need to add one day to the end date because Booking.com expects the guest departure date
      $to_date = new \DateTime($day);
      $to_date = $to_date->add(new \DateInterval('P1D'))->format('Y-m-d');
      $message[$i] = array(
        'room_id' => $room_id,
        'rate_id' => $rate_id,
        'date_range' => array(
          'from' => $start_date,
          'to' => $to_date,
        ),
        'roomstosell' => $rooms,
      );
      $old_count = $rooms;
    }
  }

  // Formatting the message based on what the channel connector expects
  $final_message = array(
    'hotel_id' => $property_id,
    'rooms' => $message,
  );

  return $final_message;
}

/**
 * Retrieve availability information for a given date range and format appropriately
 *
 * @param $property_id
 * @param $type_id
 * @param $start_date
 * @param $end_date
 * @return array
 */
function roomify_channel_type_availability($property_id, $type_id, $start_date, $end_date) {

  // Load all the units associated with that type
  $controller = entity_get_controller('bat_unit');

  // Get the units that belong to the relevant room id
  $entities = $controller->getReferencedIds($type_id);

  // Create an array of unit objects - that we will pass to the calendar
  $units = array();
  foreach ($entities as $entity) {
    $eo = bat_unit_load($entity['id']);
    $units[] = new Unit($entity['id'], $eo->getEventDefaultValue('availability'));
  }

  // Create an event store for availability type events
  $event_store = new DrupalDBStore('availability', DrupalDBStore::BAT_STATE);

  // Provided that we have units let's check availability
  if (!empty($units)) {
    $calendar = new Calendar($units, $event_store);

    $interval = new \DateInterval('P1D');
    $daterange = new \DatePeriod(new \DateTime($start_date), $interval, new \DateTime($end_date));

    $rooms_available = array();
    foreach ($daterange as $date) {
      $response = $calendar->getMatchingUnits($date, $date, array(1) );
      $rooms_available[$date->format('Y-m-d')] = count($response->getIncluded());
    }

    // With the units in place we can create the properly formatted message.
    $message = array();
    $i = -1;
    $old_count = 0;
    $start = TRUE;
    foreach ($rooms_available as $day => $rooms) {
      if ($old_count != $rooms) {
        $start_date = $day;
        $i++;
      }
      // Add one day to the end date.
      $to_date = new \DateTime($day);
      $to_date = $to_date->add(new \DateInterval('P1D'))->format('Y-m-d');
      $message[$i] = array(
        'room_id' => $room_id,
        'rate_id' => $rate_id,
        'date_range' => array(
          'from' => $start_date,
          'to' => $to_date,
        ),
        'roomstosell' => $rooms,
      );
      $old_count = $rooms;
    }
  }

  // Formatting the message based on what the channel connector expects.
  $final_message = array(
    'hotel_id' => $property_id,
    'rooms' => $message,
  );

  return $final_message;
}

/**
 * Retrieve pricing information for a given date range and format appropriately
 *
 * @param $hotel_id
 * @param $room_id
 * @param $rate_id
 * @param $start_date
 * @param $end_date
 * @return array
 */
function roomify_channel_connector_rates($property_id, $room_id, $rate_id, $start_date, $end_date) {

  $roomify_rate_id = NULL;
  $map = roomify_channel_connector_get_map_external($property_id, 'booking_com');

  if ($map != FALSE) {
    // Load the map
    $map = roomify_channel_map_load($map->channel_map_id);
    foreach ($map->data as $property) {
      foreach ($property as $internal_rate_id =>  $rate_details) {
        if (($rate_details['standardrate'] == $rate_id) && $rate_details['roomid'] == $room_id) {
          $roomify_rate_id = $internal_rate_id;
        }
      }
    }
  }
  if ($roomify_rate_id == NULL) {
    return '';
  }

  // First we should map the hotelid and roomid to a property and room
  //@TODO - create the ChannelMap entity so that given a hotel_id, room_id and rate_id we can retrieve the correct
  // rooms and rate. That should lead us to a type and rate id.
  $currency_setting = commerce_currency_load(commerce_default_currency());

  $rate = roomify_rate_load($roomify_rate_id);
  $rates = array(
    $rate->rate_id => new Unit($rate->rate_id, $rate->getEventDefaultValue('pricing')),
  );

  // Create an event store for pricing type events
  $state_store = new DrupalDBStore('pricing', DrupalDBStore::BAT_STATE);

  $calendar = new Calendar($rates, $state_store);
  $events = $calendar->getEvents(new \DateTime($start_date), new \DateTime($end_date));

  $message = array();
  foreach ($events as $unit => $unit_events) {
    foreach ($unit_events as $event) {
      $to_date = $event->getEndDate();
      $to_date = $to_date->add(new \DateInterval('P1D'))->format('Y-m-d');

      $message[] = array(
        'room_id' => $room_id,
        'rate_id' => $rate_id,
        'date_range' => array(
          'from' => $event->getStartDate()->format('Y-m-d'),
          'to' => $to_date,
        ),
        'price' => commerce_currency_amount_to_decimal($event->getValue(), $currency_setting['code'])
      );
    }
  }

  // Formatting the message based on what the channel connector expects
  $final_message = array(
    'hotel_id' => $property_id,
    'rooms' => $message,
  );

  return $final_message;
}

/**
 * Channel Management tab.
 */
function roomify_channel_connector_management_tab($property) {
  $content = array();

  foreach (module_implements('roomify_channel_connector_channel') as $module) {
    $function = $module . '_roomify_channel_connector_channel';
    $form = $function($property);
    $form_id = $form['#form_id'];

    $form_state = form_state_defaults();
    $form_state['build_info']['args'] = array($property);

    if (!isset($form_state['input'])) {
      $form_state['input'] = $form_state['method'] == 'get' ? $_GET : $_POST;
    }

    // Go through the FAPI preparation and processing stages.
    drupal_prepare_form($form_id, $form, $form_state);
    drupal_process_form($form_id, $form, $form_state);
    $content[] = $form;
  }

  return $content;
}

/**
 * Helper function - get roomify site ID.
 */
function roomify_channel_connector_get_site_id() {
  return variable_get('roomify_channel_connector_site_id', '');
}

/**
 * Implements hook_roomify_channel_connector_channel().
 */
function roomify_channel_connector_roomify_channel_connector_channel($property) {
  $content = drupal_get_form('roomify_channel_bookingcom_admin_form', $property);
  return $content;
}


function roomify_channel_connector_get_map_internal($property_id, $bundle) {

  // Check if we have an existing map
  $efq = new EntityFieldQuery();
  $efq->entityCondition('entity_type', 'roomify_channel_map')
    ->entityCondition('bundle', $bundle, '=')
    ->propertyCondition('internal_property_id', $property_id, '=')
    ->range(0, 1);

  $result = $efq->execute();
  if (count($result)) {
    return array_values($result['roomify_channel_map'])[0];
  }
  else {
    return FALSE;
  }
}

function roomify_channel_connector_get_map_external($property_id, $bundle) {

  // Check if we have an existing map
  $efq = new EntityFieldQuery();
  $efq->entityCondition('entity_type', 'roomify_channel_map')
    ->entityCondition('bundle', $bundle, '=')
    ->propertyCondition('external_property_id', $property_id, '=')
    ->range(0, 1);

  $result = $efq->execute();
  if (count($result)) {
    return array_values($result['roomify_channel_map'])[0];
  }
  else {
    return FALSE;
  }
}


/**
 * Channel management forms for type channel management tab.
 */
function roomify_channel_bookingcom_admin_form($form, &$form_state, $property) {
  $form['#attached']['css'] = array(drupal_get_path('module', 'roomify_channel_connector') . '/css/roomify_channel_connector.css');

  $form['#prefix'] = '<div id="roomify_channel_bookingcom_admin_form">';
  $form['#suffix'] = '</div>';

  // Load the types as we may be needing them.
  foreach ($property->property_bat_type_reference[LANGUAGE_NONE] as $id) {
    $bat_types[] = bat_type_load($id['target_id'], TRUE);
  }

  // Check if there is a channel map for Booking.com for this property.
  $map = roomify_channel_connector_get_map_internal($property->property_id, 'booking_com');
  if ($map != FALSE) {
    $map = roomify_channel_map_load($map->channel_map_id);
  }

  $form['bookingcom_map'] = array(
    '#type' => 'fieldset',
    '#title' => t('Booking.com Channel Configuration'),
  );

  $form['bookingcom_map']['property_id'] = array(
    '#type' => 'hidden',
    '#value' => $property->property_id,
  );

  $form['bookingcom_map']['roomify_channel_bookingcom_hotel_id_' . $property->property_id] = array(
    '#type' => 'textfield',
    '#title' => 'Your Booking.com Hotel ID',
    '#description' => 'You can get this ID by logging in to your Booking.com account - once there you should also set Roomify as your channel manager.',
    '#default_value' => isset($map->external_property_id) ? $map->external_property_id : '',
    '#required' => TRUE,
  );

  $form['bookingcom_map']['connect'] = array(
    '#type' => 'submit',
    '#value' => t('Connect'),
    '#limit_validation_errors' => array(array('roomify_channel_bookingcom_hotel_id_' . $property->property_id)),
    '#submit' => array('roomify_channel_bookingcom_admin_form_connect_submit'),
    '#ajax' => array(
      'callback' => 'roomify_channel_bookingcom_admin_form_callback',
      'wrapper' => 'roomify_channel_bookingcom_admin_form',
    ),
  );

  if (isset($map->external_property_id)) {
    $form['bookingcom_map']['roomify_channel_bookingcom_hotel_id_' . $property->property_id]['#disabled'] = TRUE;
    $form['bookingcom_map']['connect']['#disabled'] = TRUE;
  }

  if (isset($form_state['input']['roomify_channel_bookingcom_hotel_id_' . $property->property_id])) {
    $reply = roomify_channel_connector_get_bookingcom_ids($form_state['input']['roomify_channel_bookingcom_hotel_id_' . $property->property_id]);

    // Create room type options for use in form
    if ($reply != FALSE) {
      $options = array();
      $options['0'] = 'N/A';
      foreach ($reply->roomrates->rooms as $room_id => $room) {
        $options[$room_id] = $room->name;
      }

      // Create a field for each bat type to map to a room type and the standard rate for that room
      foreach ($bat_types as $bat_type) {
        $form['bookingcom_map']['roomify_channel_bookingcom_' . $bat_type->type_id] = array(
          '#type' => 'fieldset',
          '#title' => $property->name . ' - ' . $bat_type->name . ': ' . t('Select Booking.com Equivalent'),
        );

        $form['bookingcom_map']['roomify_channel_bookingcom_' . $bat_type->type_id]['roomify_channel_bookingcom_roomid_' . $property->property_id . '_' . $bat_type->type_id] = array(
          '#type' => 'select',
          '#options' => $options,
          '#default_value' => 0,
          '#ajax' => array(
            'callback' => 'roomify_channel_bookingcom_admin_form_callback',
            'wrapper' => 'roomify_channel_bookingcom_admin_form',
          ),
        );
        // Create a field to map the standard Roomify rate to the Booking.com rate
        if (isset($form_state['input']['roomify_channel_bookingcom_roomid_' . $property->property_id . '_' . $bat_type->type_id]) && $form_state['input']['roomify_channel_bookingcom_roomid_' . $property->property_id . '_' . $bat_type->type_id] != 0) {

          $rate_options = array();
          // Create rate type options for use in form
          $room_id = $form_state['input']['roomify_channel_bookingcom_roomid_' . $property->property_id . '_' . $bat_type->type_id];
          foreach ($reply->roomrates->rooms->$room_id->rates as $rate_id => $rate) {
            $rate_options[$rate_id] = $rate->rate_name;
          }

          $form['bookingcom_map']['roomify_channel_bookingcom_' . $bat_type->type_id]['roomify_channel_bookingcom_standardrate_' . $property->property_id . '_' . $bat_type->type_id] = array(
            '#type' => 'select',
            '#options' => $rate_options,
            '#empty_option' => t('- select rate -'),
            '#default_value' => '',
          );
        }
      }
    }
  }

  // If the Property ID is set then we can proceed to map the rest
  if (isset($map->external_property_id)) {
    $reply = roomify_channel_connector_get_bookingcom_ids($map->external_property_id);

    // Create room type options for use in form
    if ($reply != FALSE) {
      $options = array();
      $options['0'] = 'N/A';
      foreach ($reply->roomrates->rooms as $room_id => $room) {
        $options[$room_id] = $room->name;
      }

      // Create a field for each bat type to map to a room type and the standard rate for that room
      foreach ($bat_types as $bat_type) {
        $form['bookingcom_map']['roomify_channel_bookingcom_' . $bat_type->type_id] = array(
          '#type' => 'fieldset',
          '#title' => $property->name . ' - ' . $bat_type->name . ': ' . t('Select Booking.com Equivalent'),
        );

        $form['bookingcom_map']['roomify_channel_bookingcom_' . $bat_type->type_id]['roomify_channel_bookingcom_roomid_' . $property->property_id . '_' . $bat_type->type_id] = array(
          '#type' => 'select',
          '#options' => $options,
          '#default_value' => isset($map->data[$property->property_id][$bat_type->type_id]['roomid']) ? $map->data[$property->property_id][$bat_type->type_id]['roomid'] : 0,
          '#ajax' => array(
            'callback' => 'roomify_channel_bookingcom_admin_form_callback',
            'wrapper' => 'roomify_channel_bookingcom_admin_form',
          ),
        );

        // Create a field to map the standard Roomify rate to the Booking.com rate
        if (isset($form_state['input']['roomify_channel_bookingcom_roomid_' . $property->property_id . '_' . $bat_type->type_id])) {
          if ($form_state['input']['roomify_channel_bookingcom_roomid_' . $property->property_id . '_' . $bat_type->type_id] != 0) {
            $rate_options = array();
            // Create rate type options for use in form
            $room_id = $form_state['input']['roomify_channel_bookingcom_roomid_' . $property->property_id . '_' . $bat_type->type_id];
            foreach ($reply->roomrates->rooms->$room_id->rates as $rate_id => $rate) {
              $rate_options[$rate_id] = $rate->rate_name;
            }

            $form['bookingcom_map']['roomify_channel_bookingcom_' . $bat_type->type_id]['roomify_channel_bookingcom_standardrate_' . $property->property_id . '_' . $bat_type->type_id] = array(
              '#type' => 'select',
              '#options' => $rate_options,
              '#empty_option' => t('- select rate -'),
              '#default_value' => '',
            );
          }
        }
        elseif (isset($map->data[$property->property_id][$bat_type->type_id]['roomid']) && $map->data[$property->property_id][$bat_type->type_id]['roomid'] != 0) {

          $rate_options = array();
          // Create rate type options for use in form
          $room_id = $map->data[$property->property_id][$bat_type->type_id]['roomid'];
          foreach ($reply->roomrates->rooms->$room_id->rates as $rate_id => $rate) {
            $rate_options[$rate_id] = $rate->rate_name;
          }

          $form['bookingcom_map']['roomify_channel_bookingcom_' . $bat_type->type_id]['roomify_channel_bookingcom_standardrate_' . $property->property_id . '_' . $bat_type->type_id] = array(
            '#type' => 'select',
            '#options' => $rate_options,
            '#empty_option' => t('- select rate -'),
            '#default_value' => isset($map->data[$property->property_id][$bat_type->type_id]['standardrate']) ? $map->data[$property->property_id][$bat_type->type_id]['standardrate'] : 0,
          );
        }
      }
    }
  }

  $form['#validate'][] = 'roomify_channel_bookingcom_admin_form_validate';

  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Update Booking.Com Mapping'),
  );

  if (!isset($map->external_property_id) && !isset($form_state['input']['roomify_channel_bookingcom_hotel_id_' . $property->property_id])) {
    $form['actions']['submit']['#disabled'] = TRUE;
  }

  if (isset($map->external_property_id)) {
    $form['actions']['remove'] = array(
      '#type' => 'submit',
      '#value' => t('Disconnect'),
      '#submit' => array('roomify_channel_bookingcom_admin_form_disconnect_submit'),
    );
  }

  $form['#submit'][] = 'roomify_channel_bookingcom_admin_form_submit';

  return $form;
}

/**
 * Ajax callback for the roomify_channel_bookingcom_admin_form form.
 */
function roomify_channel_bookingcom_admin_form_callback($form, &$form_state) {
  return $form;
}

/**
 * Submit for the "Connect" button on roomify_channel_bookingcom_admin_form form.
 */
function roomify_channel_bookingcom_admin_form_connect_submit($form, &$form_state) {
  $form_state['rebuild'] = TRUE;
}

/**
 * Submit for the "Disconnect" button on roomify_channel_bookingcom_admin_form form.
 */
function roomify_channel_bookingcom_admin_form_disconnect_submit($form, &$form_state) {
  $map = roomify_channel_connector_get_map_internal($form_state['values']['property_id'], 'booking_com');

  $channel_map = roomify_channel_map_load($map->channel_map_id);
  roomify_channel_map_delete($channel_map);
}

/**
 * Validation handler for bookingcom form.
 */
function roomify_channel_bookingcom_admin_form_validate($form, &$form_state) {
  if (isset($form_state['input']['roomify_channel_bookingcom_hotel_id_' . $form_state['values']['property_id']]) &&
      !empty($form_state['input']['roomify_channel_bookingcom_hotel_id_' . $form_state['values']['property_id']])) {
    $external_property_id = $form_state['input']['roomify_channel_bookingcom_hotel_id_' . $form_state['values']['property_id']];
  }
  else {
    $external_property_id = $form_state['values']['roomify_channel_bookingcom_hotel_id_' . $form_state['values']['property_id']];
  }

  $internal_property_id = $form_state['values']['property_id'];

  if ($external_property_id == '') {
    form_set_error('roomify_channel_bookingcom_hotel_id_' . $form_state['values']['property_id'], t('Please provide us with the Hotel ID on Booking.com.'));
  }
  if ($external_property_id != '') {
    $reply = roomify_channel_connector_get_bookingcom_ids($external_property_id);
    if (!$reply) {
      form_set_error('roomify_channel_bookingcom_hotel_id_' . $form_state['values']['property_id'], t('Error connecting to property on Booking.com - please check ID or contact support'));
    }

    // Also check to see that no other property is using this property id
    $map = roomify_channel_connector_get_map_external($external_property_id, 'booking_com');
    if ($map != FALSE) {
      $map = roomify_channel_map_load($map->channel_map_id);
      if ($map->internal_property_id != $internal_property_id) {
        form_set_error('roomify_channel_bookingcom_hotel_id_' . $form_state['values']['property_id'], t('Another property is already mapped to this Booking.com property. Please contact your site administrator.'));
      }
    }
  }

  // User should not map two rooms to the same option
  $previous_value = 0;
  foreach ($form_state['values'] as $key => $value) {
    $k = explode('_', $key);
    if (isset($k[3]) && $k[3]=='roomid') {
      if ($value != 0) {
        if ($value == $previous_value) {
          form_set_error('roomify_channel_bookingcom_roomid_' . $k[4] . '_' . $k[5], t('Another room is already mapped to this Booking.com Room.'));
        }
        else {
          $previous_value = $value;
        }
      }
    }
  }
}

/**
 * Submit handle for bookingcomform
 */
function roomify_channel_bookingcom_admin_form_submit(&$form, &$form_state) {
  global $user;

  // Check if there is a property map already
  $map = roomify_channel_connector_get_map_internal($form_state['values']['property_id'], 'booking_com');

  // Update the existing map
  if ($map != FALSE) {
    $map = roomify_channel_map_load($map->channel_map_id);
    $map->internal_property_id = $form_state['values']['property_id'];
    $map->external_property_id = $form_state['values']['roomify_channel_bookingcom_hotel_id_' . $form_state['values']['property_id']];


    $map->changed = time();

    entity_save('roomify_channel_map', $map);

  }
  else {
    // Create a channel map entity
    $values = array(
      'channel_map_id' => '',
      'internal_property_id' => $form_state['values']['property_id'],
      'external_property_id' => $form_state['values']['roomify_channel_bookingcom_hotel_id_' . $form_state['values']['property_id']],
      'type' => 'booking_com',
      'uid' => $user->uid,
      'created' => time(),
      'is_new' => TRUE,
    );

    $map = roomify_channel_map_create($values);
    entity_save('roomify_channel_map', $map);
  }

  // Now deal with room mappings - we will cycle through values looking for keys that end in room
  foreach ($form_state['values'] as $key => $value) {
    $k = explode('_', $key);
    if (isset($k[3]) && $k[3]=='roomid') {
      if ($value != 0) {
        $map->data[$k[4]][$k[5]]['roomid'] = $value;
        entity_save('roomify_channel_map', $map);
      }
    }
  }

  // Check to see if there are rates to map
  foreach ($form_state['values'] as $key => $value) {
    $k = explode('_', $key);
    if (isset($k[3]) && $k[3]=='standardrate') {
      if ($value != 0) {
        $map->data[$k[4]][$k[5]]['standardrate'] = $value;
        entity_save('roomify_channel_map', $map);
      }
    }
  }
}

/**
 * Retrieve Room / Rates ID from channel manager
 */
function roomify_channel_connector_get_bookingcom_ids($hotel_id) {
  $cm_export_url = CM_URL . 'bc/roomrates/' . $hotel_id;
  $request = drupal_http_request($cm_export_url);
  if ($request->data) {
    $reply = json_decode($request->data);

    if (isset($reply->roomrates->fault->code)) {
      return FALSE;
    }
    else {
      return $reply;
    }
  }

  return FALSE;
}

function roomify_channel_connector_entity_update($entity, $type) {
  if ($type == 'bat_event' && ($entity->type == 'pricing' || $entity->type == 'availability')) {
    // Check if we have a site id (which implies we are connected)
    if (variable_get('roomify_channel_connector_site_id') != '') {
      roomify_channel_connector_notify_change($entity);
    }
  }
}

function roomify_channel_connector_entity_insert($entity, $type) {
  if ($type == 'bat_event' && ($entity->type == 'pricing' || $entity->type == 'availability')) {
    if (variable_get('roomify_channel_connector_site_id') != '') {
      $entity->start_date_object = new DateTime($entity->start_date);
      $entity->end_date_object = new DateTime($entity->end_date);
      roomify_channel_connector_notify_change($entity);
    }
  }
}

function roomify_channel_connector_notify_change($entity) {
  $rate = roomify_rate_load($entity->event_roomify_rate_reference[LANGUAGE_NONE][0]['target_id']);
  if ($rate->type == 'standard') {
    // Load the bat type associated with this rage
    $bat_type = bat_type_load($rate->rate_bat_type_reference[LANGUAGE_NONE][0]['target_id']);
    // using the property ID check if there is a booking.com mapping for this property
    $map = roomify_channel_connector_get_map_internal($bat_type->field_st_property_reference[LANGUAGE_NONE][0]['target_id'], 'booking_com');
    if ($map != FALSE) {
      // A map is in place let us pull relevant rate info and sent to CM
      $map = roomify_channel_map_load($map->channel_map_id);
      $internal_id = $map->internal_property_id;
      $external_id = $map->external_property_id;
      // Get rate changes
      $rate_changed = $map->data[$internal_id][$bat_type->type_id]['standardrate'];
      $room_changed = $map->data[$internal_id][$bat_type->type_id]['roomid'];

      $message = array(
        'site_id' => variable_get('roomify_channel_connector_site_id'),
        'h_id' => $external_id,
        'rate_id' => $rate_changed,
        'room_id' => $room_changed,
        'start_date' => $entity->start_date_object->format('Y-m-d'),
        'end_date' => $entity->end_date_object->format('Y-m-d'),
        'type' => $entity->type
      );
      $cm_url = CM_URL . 'bc/rate-change-notification?';
      foreach ($message as $key => $value) {
        $cm_url .= $key . '=' . $value . '&';
      }
      $request = drupal_http_request($cm_url);
      $reply = json_decode($request->data);
    }
  }
}
